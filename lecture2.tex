\documentclass[a4paper,12pt]{article} 
\usepackage[T2A]{fontenc}			
\usepackage[utf8]{inputenc}			
\usepackage[english,russian]{babel}	
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 
\usepackage{wasysym}
\usepackage{amsmath}

\author{конспект от TheLostDesu}
\title{Машина Тьюринга}
\date{\today}


\begin{document}
\maketitle
\section{Улучшения машин Тьюринга}
1) В начальном состоянии головка стоит сразу после слова.\\
2) В конечном состоянии головка стоит сразу после слова.\\
Машина Тьюринга называется нормальной, если она удвлетворяет условиям 1 и 2.

Для более удобной работы с лентой ее можно ограничить с одного конца. Мы не потеряем ничего в мощности вычисления\\
Доказательство того, что мощность вычисления не теряется:
Пронумеруем все ячейки. Перенумеруем их. Если номер ячейки меньше нуля, то умножим модуль номера ячейки на два. Если больше - умножим на 2 и вычтем 1. Новая машина имеет только ячейки больше нуля. А так как у нас счетная бесконечность ячеек справа - число ячеек на самом деле не изменилось. Но это изменит возможность передвижения головки. Оно станет зависеть от четности и нечетности, но машина не знает на какой клетке она стоит. Поэтому, следует помечать нулевую ячейку и "размножать" состояния. То есть, делать делать состояния для "четных" ячеек, и для "нечетных". 

Машина с укороченными инструкциями. Разобьем все инструкции на две. Одна из них - <<Записать>>, вторая - <<Передвинуться>>.\\
Это показывает как работают современные процессоры. Они могут иметь много типов инструкций. Это позволяет супербыстро считать всякое(аппаратно), но это увеличивает размер процессоров, а так же уменьшает их быстродействие. Но они же могут иметь и мало типов инструкций. Это позволит быстро передавать информацию между ячейками, но не позволит делать сложные вещи аппаратно. 
\section{Диаграмма Тьюринга}
Запись символа или сдвиг вправо называются <<элементарными действиями>>\\
 Тогда превратим запись машины в одну строку. Так например $\cdot lr\cdot $ - машина, которая двигает головку влево, а потом вправо. За выбор продолжения отвечают стрелочки. Условие перехода записывается над ними. В итоге получается удобный способ программировать машины Тьюринга, гораздо более простой, чем создавать огромные таблицы. \\

Пусть нам нужно написать <<Копирующюю машину>>. Она должна переводить, например ленту <<$\lambda 0\lambda \lambda \lambda$>> в <<$\lambda 0\lambda 0 \lambda$. \\
1. Пусть мы уже придумали, как скопировать символ. Но нужно будет как-то вернуться обратно. Тогда будем вводить промежуточный символ, чтобы запомнить место откуда мы скопировали что-то. Тогда будем ставить лямбду там, откуда мы скопировали что-то\\
2. перейдем в состояние, которое соответствует нашему символу.\\
3. Для копирования нужно найти куда копировать. Просто идем вправо, пока мы не заметим лямбду, сдвигаемся на еще один символ вправо, сюда будем копировать. \\
4. Пишем символ из нашего состояния. \\
5. Возвращаемся на лямбду\\
6. Записываем наш символ обратно\\
\section{Построение таблиц по диаграммам}
1. Заменим упрощенную диаграмму полной\\
2. Добиваемся, чтобы каждый символ MT входил в нее только один раз\\
3. Сопостовляем каждому символу MT ее таблицу\\
4.Перепишем таблицы одну за другой(в любой последовательности)\\
5. Добавим в таблицу строки:\\
5.1 Для каждого символа, стрелка из которого ведет к нему же - строку q0a -> aq0\\
5.2 Строки в точки MT\\
5.3 Строки в состояние останова.\\
\section{Моделирование МТ}
По факту, если есть "Большая" машина M, и "Маленькая" машина M', и большая машина может сделать все то же самое, что и маленькая, и еще, возможно чуть больше.
МТ М моделирует МТ M', если:\\

Универсальная машина тьюринга для алфавита A\footnote{Можно построить УМТ для любого алфавита, так как можно кодировать один алфавит другим} называется такая машина $U$, на которой может быть промоделированна любая МТ над алфавитом A.\\
В УМТ можно подавать <<Слово - программу>>, которая будет показывать, что следует моделировать. Все части программы разделены специальным символом, в конце стоит символ завершения.

Для моделирования машины:\\
Найти правило для выполнения\\
Изметить конфигурацию МТ\\
Перейти на новый такт\\

\section{Неразрешимая задача}
Есть несколько известных задач, которые нерешимы алгоритмически. Одна из которых - проблема останова. Некоторые из задач нельзя разрешить, ведь тогда проблема останова будет решена. 
Докажем это от противного. Пусть есть некоторая машина D(T, W). Строим по ней машину E, которая вместо входных данных <<подсовывает>> ей свою же машину. E(T) = D(T, T). Теперь построим машину E*. Если машина E останавливается-  она зациклит ее. Иначе остановит. Если теперь запустить(E*(E*)) остановится ли она?
\end{document}